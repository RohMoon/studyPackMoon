### 제네릭 / Generic

- 제네릭이란 JDK 1.5부터 도입된 **_클래스 내부에서 사용할 데이터 타입_** 을 외부에서 지정하는 기법이다.

```java
//List interface
public interface List<E> extends Collection<E> {
    //...
}
```

```java
import java.util.ArrayList;

class Generic<E> {

    public static void main(String[] args) {
        List<String> words = new ArrayList<>();
    }
}
```

- 제네릭 사용 이유 예제

```java
class GenericEx {
    public static void main(String[] args) {
        List numbers = arrays.asList(1, 2, 3, 4, 5, 6);
        int sum = 0;
        for (Object number : numbers) {
            sum += (int) number;
        }
    }
}
```

위는 List안에 모든 숫자를 더하는 로직이다. List에 타입 지정을 안했기 때문에 Object로 타입이 지정되고 더하는 부분에서 형 변환을 직접 해줘야 하는 번거로움이 있다.  
위 예제에서는 형 변환을 한번 밖에 안했지만 만약 타입 지정을 안 한 List가 사용되는 곳이 1000군데가 넘는다면 1000군데서 전부 예제처럼 직접 형변환을 해줘야 하는 번거로움이 있다.

제네릭을 사용한다면 아래와 같아진다.

```java
import java.util.Arrays;

class UseGeneric {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
        int sum = 0;
        for (Integer number : numbers) {
            sum += number;
        }
    }
}
```

불필요한 형 변환 없이 코드가 깔끔해진다. 또한 타입 안전성이 있다.

```java
import java.util.Arrays;

class UseGeneric {
    public static void main(String[] args) {
        List numbers = Arrays.asList("1", "2", "3", "4", "5", "6");
        int sum = 0;
        for (Object number : numbers) {
            sum += (int) number;
        }
    }
}
```

int형으로 형 변환을 해주며 더해주지만 List의 요소가 int형이라는 보장이 없다. 위 예제와 같이 List에 문자열을 넣어주어도 컴파일 에러가 발생하지 않고 ClassCastException 이 터지게 된다.
컴파일시 타입을 체크하고 에러를 찾아낼 수 있는 컴파일 언어의 장점을 발휘하지 못하는 셈이다.

제네릭을 사용했다면 아래와 같이 컴파일 시에 의도하지 않은 타입이 들어오는걸 막을 수 있다.

```java
import java.util.Arrays;

class UseGeneric {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList("1", "2", "3", "4", "5", "6");
        int sum = 0;
        for (Integer number : numbers) {
            sum += number;
        }
        System.out.println(sum);
    }
}
```

------

### 타입 파라미터 컨벤션

- 제네릭에서 사용하는 타입 파라미터에 자주 봤던 T 같은 문자가 아니고 아무런 문자나 넣어도 코드가 작동하는 데는 문제가 없다.

```java
public class Car<DunDung> {
    private final DunDung name;
    //...
}
```

하지만 타입 파라미터에도 컨벤션이 존재한다.
> [ Code Conventions for the Java Programming Language 글의 Why Have Code Conventions 코드 컨벤션:](https://www.oracle.com/java/technologies/javase/codeconventions-introduction.html#16712)

- 아래는 타입 파라미터 컨벤션이다.
  ![img.png](img.png)

1. E - Element ( used extensively by the Java Collections FrameWork)
2. K - Key
3. N - Number
4. T - Type
5. V - Value
6. S,U,V etc. - 2nd, 3rd ,4th types 제네릭 클래스나 메서드를 구현할 일이 있다면 컨벤션에 맞추어서 구현할 것.

------

### 제네릭 메서드

- 제네릭 타입을 메서드 리턴 타입 앞에 선언한 메서드를 제네릭 메서드라 한다.

```java

public class Car<T> {
    private final T name;

    private Car(T name) {
        this.name = name;
    }

    public static <M> Car<M> from(m name) {
        return new Car<>(name);
    }

    public <M> void printEqualsCar(Car<M> car) {
        System.out.println(this.equals(car));
    }
}
```

- 위와 같은 Car 클래스에서 from 메서드와 printEqualsCar 메서드가 제네릭 메서드이다. 이해를 돕기 위해 제네릭 메서드 타입을 컨벤션에 맞지 않게 `<M>` 으로 정한 점을 이해해주시길 바란다.

- 제네릭 메서드 타입 `<M>`를 리턴 타입 앞에 붙여서 표시하므로 헷갈릴 수 있는데, 제네릭 타입을 메서드 리턴 타입 앞에 붙여주는 것이 문법일 뿐이다. 메서드 리턴 타입과는 다른 영역이다.

- 또한 클래스에 선언한 `<T>`와 제네릭 메서드에 붙인 `<M>` 과는 관련이 없다. 제네릭 메서드에 붙인 `<M>`과 같은 타입은 해당 메서드에서만 적용되는 제네릭 타입이다.

- 제네릭 메서드를 사용하려면 반드시 리턴 타입 앞에 해당 메서드에서 어떤 제네릭 타입을 사용할 것인지를 붙여줘야 한다는 것을 기억하자.  
  아래와 같은 형태는 컴파일 에러가 난다.

```java
public class Car<T> {
    public static Car<M> from(M name) { //컴파일 에러
        return new Car<>(name);
    }
    //... 
}
```

- 마지막으로 제네릭 클래스가 아닌 일반 클래스에서도 제네릭 메서드를 사용할 수 있다는 점을 기억하자.

----

### 제한된 제네릭

- 제네릭은 원하는 타입이 있을때도 모든 타입이 들어올 수 있는 문제가 있다.

```java
public class Car<T> {
    private final T name;

    public Car(T name) {
        this.name = name;
    }
    //...
}
```

위와 같은 Car 클래스 인스턴스 변수 name은 문자 관련 타입 지정되기를 원해도 아래와 같이 아무 타입이나 들어올 수 있다.

```java
public class Car<T> {
    public static void main(String[] args) {
        Car<Integer> car = new Car<>(1);
    }
}
```

이럴 때 타입 뒤에 `extends` 키워드를 사용해 타입을 제한시킬 수 있다.

```java
public class Car<T extends CharSequence> {
    private final T name;

    public Car(T name) {
        this.name = name;
    }
    //...
}
```

CharSequence 인터페이스 하위 객체들만 데이터 타입으로 지정할 수 있게 함으로써 인스턴스 변수 name에 문자열 관련 타입만 지정할 수 있게 되었다.

```java
class Ex {
    public static void main(String[] args) {
        Car<String> car = new Car<>("sports");
    }
}
```

아래와 같이 `Collections.sort` 에서도 제한된 제네릭을 사용하고 있다.

```java
class ex {
    public static <T extends Comparable<? super T>> void sort(List<T> list) {
        list.sort(null);
    }
}
```

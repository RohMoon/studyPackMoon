## List Interface

- List 인터페이스에서 지원하는 클래스들 (ex.ArrayList,LinkedList)의 공통점과 차이점.
    - <span style="color:#ffd33d">[공통점]</span>
        - 동일한 특성의 데이터들을 묶는다.
        - 반복문(loop) 내에 변수를 이용하여 하나의 묶음 데이터들을 모두 접근할 수 있다.
    - <span style="color:#81F781">[차이점 -배열]</span>
        - 처음 선언한 배열의 크기(길이)는 변경할 수 없다. 이를 정적 할당 (static allocation)이라고 한다.
        - 메모리에 연속적으로 나열되어 할당된다.
        - index에 위치한 하나의 데이터(element)를 삭제하더라도 해당 index에는 빈공간으로 계속 남는다.
    - <span style="color:#2EFEF7">[차이점 -리스트]</span>
        - 리스트의 길이가 가변적이다 .이를 동적 할당(dynamic allocation)이라고 한다.
        - 데이터들이 연속적으로 나열된다. (메모리에 연속적으로 나열되지 않고 각 데이터들은 주소(reference)로 연결되어 있다. C에서의 포인터.)
        - 데이터(element)사이에 빈공간을 허용하지 않는다.

    - <span style="color:#E2A9F3">[배열의 장/단점]</span>
        - <span style="color:#FAAC58"><장점></span>
            - 데이터의 크기가 정해져있을 경우 메모리 관리가 편하다.
            - 메모리에 연속적으러 나열되어 할당하기 대문에 index를 통한 색인(접근속도)가 빠르다.
        - <span style="color:#FE2E2E"><단점></span>
            - 배열의 크기를 변경할 수 없기 때문에 초기에 너문 큰 크기로 설정해주었을 경우 메모리 낭비가 심해지고, 반대로 너무 작은 크기로 설정해주었을 경우 데이터를 다 못 담을 수 있는 경우가
              발생한다.
            - 빈 공간을 허용하지 않고 데이터를 삽입(add), 삭제(remove)를 하고자 한다면, 뒤의 데이터들을 모두 밀어내거나 당겨주어야 하기 때문에 속도가 느려 삽입, 삭제가 빈번한 경우에는
              유용하지 않다.


- ###### <span style="color:#9A2EFE">[리스트의 장단점]</span>
    - <span style="color:#F7FE2E"><장점></span>
        - 데이터의 개수에 따라 해당 개수만큼 메모리를 동적 할당해주기 때문에 메모리 관리가 편리해진다.
        - 빈 공간을 허용하지 않기 때문에 데이터 관리에도 편하다.
        - 포인터(주소)로 각 데이터들이 연결되어 있기 때문에 해당 데이터에 연결된 주소만 바꿔주면 되기 때문에 삽입 삭제에 용이하다.(ArrayList는 예외)
    - <span style="color:#F7FE2E"><단점></span>
        - 객체로 데이터를 다루기 때문에 적은 양의 데이터만 쓸 경우 배열에 비해 차지하는 메모리가 커진다.  
          예로 primitive type인 int는 4Byte를 차지한다. 반면에 Wrapper class인 Integer는 32bit JVM에선 객체의 헤더 (8Byte), 원시 필드(4Byte), 패딩(
          4Byte)으로 "최소 16Byte"를 차지한다.  
          거기에다 이러한 객체데이터들을 다시 주소로 연결하기 때문에 16 + a 가 된다.
        - 기본적으로 주소를 기반으로 구성되어 있고 메모리에 순차적으로 할당하는 것이 아니기 때문에 (물리적 순차저적이지않다.)색인 능력은 떨어진다.

> 인터페이스에 대해서 잠깐 설명 :
> Interface는 추상메서드 (구현되지 않고 선언만 된 메서드)들의 모임이다. 이 Interface를 어느 객체에서 상속하여 사용하게 되면, 그 객체는 Interface에 선언된 추상메서드들을 '반드시' 강제적으로 구현해주어야 한다.
>
> 이는 다형성이라는 Java의 대표적 특징이다. 보통 상속(extend)와 많이 헷갈려하기 때문에 잠깐 정리해보아야 한다.
> 일반적으로 클래스 상속(extend)의 경우 이미 만들어진 클래스와 그 안의 메소드들을 자식 클래스가 사용할 수 있게 만드는 것이다.
> 즉, 상위(부모)클래스의 모든 메서드들을 사용할 수 있다는 장점은 있지만, 반대로 어느 한쪽에서 변화가 생긴다면 상속 관계가 깨져버린다는 것이다. 예로 들어 부모 클래스에 '덧셈'이라는 기능이 추가 되었는데, 자식 클래스에서 ' 덧셈' 기능을 사용하지 못하도록 한다면 상속관계가 깨져버린다는 것이다.
>
> 반대로 인터페이스(Interface)의 경우 메커니즘이 다르다. 추상메서드로만 구현되어 있기 때문에 이를 상속한 클래스는 반드시 재정의 (Override)를 하여 "구현"을 필수로 하게 만든다.  
> 그래서 Interface를 상속하는 방법 또한 extend가 아닌 implements다. (보통 자바에서는 구현이라고 표현하는데, 상속이라 해도 의미는 통하니 크게 문제가 되지 않는다. )이러한 메커니즘으로 인터페이스를 구현한 객체들은 같은 동작을 보장한다는 장점이 있다.
> 예로 들어 A라는 Interface가 있고, 그 안에 2의 n승을 구해주는 메소드인 power_Of_2()라는 메소드가 있다고 하고,
> 그리고 그 안에 2의 n승을 구해주는 메서드인 power_Of_2() 라는 메서드가 있다고 한다, 그리고 class B와 class C가 있다.
>

```java
interface A {
    //2의 n승을 구해주는 메서드
    public int power_Of_2(int n); .//무
}

class B implements A {// A를 상속(구현)
    //메소드 재정의

    @Override
    public int power_Of_2(int n) {

        int result = 1;
        for (int i = 0; i < n; i++) {
            result = result * 2;
        }
        return result;
    }
}

class C implements A { //A를 상속(구현)
//메서드 재정의


    @Override
    public int power_Of_2(int n) {
        int result = (1<< n);
        return result;
    } //A를 상속(구현)
}
```
보면 클래스 B와 C는 서로 구하는 방식은 달라도 결국 2의 n승을 구하기 위한 동작은 같다.  
이렇게 어떠한 규약을 정해놓고 관리하기 쉽게 할 수 있는 것이 바로 interface 이다.

또한 같은 interface를 구현하지만 B클래스의 성능이 너무 느려 A클래스의 메서드로 대체하고자 할 때, 그대로 사용하면 된다는 장점이 있다.

